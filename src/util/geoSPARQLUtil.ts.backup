import { Feature, FeatureCollection, Point, Polygon } from "geojson";
// @ts-expect-error - wellknown module lacks type definitions
import wellknown from "wellknown";

// RDF4J integration interface
export interface RDF4JStore {
  baseUrl: string;
  repositoryId: string;
}

export interface RDFTriple {
  subject: string;
  predicate: string;
  object: string;
  objectType: 'uri' | 'literal';
  datatype?: string;
}

// GeoSPARQLãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹
const GEOSPARQL_PREFIXES = `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX geo: <http://www.opengis.net/ont/geosparql#>
PREFIX geof: <http://www.opengis.net/def/function/geosparql/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ex: <http://example.org/disaster#>
`;

// å„ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã®å…±é€šãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®šç¾©
const DATA_PROPERTIES = {
  population: {
    type: "ex:PopulationFeature",
    properties: {
      population: "ex:population",
      meshId: "ex:meshId",
      color: "ex:color",
      shicode: "ex:shicode",
      population2020: "ex:population2020",
      population2024: "ex:population2024",
    },
  },
  landuse: {
    type: "ex:LandUseFeature",
    properties: {
      landUseCode: "ex:landUseCode",
      meshId: "ex:meshId",
      color: "ex:color",
    },
  },
  school: {
    type: "ex:SchoolFeature",
    properties: {
      P29_001: "ex:P29_001",
      P29_002: "ex:P29_002",
      P29_003: "ex:P29_003",
      P29_004: "ex:P29_004",
      P29_005: "ex:P29_005",
      P29_006: "ex:P29_006",
      P29_007: "ex:P29_007",
    },
  },
  medical: {
    type: "ex:MedicalFeature",
    properties: {
      P04_001: "ex:P04_001",
      P04_002: "ex:P04_002",
      P04_003: "ex:P04_003",
      P04_004: "ex:P04_004",
      P04_007: "ex:P04_007",
      P04_008: "ex:P04_008",
      P04_009: "ex:P04_009",
      P04_010: "ex:P04_010",
    },
  },
  disaster: {
    type: "ex:DisasterArea",
    properties: {
      type: "ex:disasterType",
      severity: "ex:severity",
      timestamp: "ex:timestamp",
    },
  },
};

// GeoJSONã‚’RDF4J Triple ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
export function convertGeoJSONToTriples(feature: Feature, type: keyof typeof DATA_PROPERTIES): RDFTriple[] {
  const { geometry, properties = {} } = feature;
  const id = properties?.id ?? crypto.randomUUID();
  const typeConfig = DATA_PROPERTIES[type];

  if (!typeConfig) {
    throw new Error(`Unsupported feature type: ${type}`);
  }

  if (geometry.type !== "Point" && geometry.type !== "Polygon" && geometry.type !== "MultiPolygon") {
    throw new Error(`Unsupported geometry type: ${geometry.type}`);
  }

  const triples: RDFTriple[] = [];

  // URIã‚’ä½œæˆ
  const featureUri = `http://example.org/disaster#${type}_${id}`;
  const geometryUri = `http://example.org/disaster#geometry_${id}`;

  // åŸºæœ¬ãƒˆãƒªãƒ—ãƒ«ã‚’è¿½åŠ 
  triples.push({
    subject: featureUri,
    predicate: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    object: `http://example.org/disaster#${typeConfig.type.replace("ex:", "")}`,
    objectType: "uri"
  });

  triples.push({
    subject: featureUri,
    predicate: "http://www.w3.org/2000/01/rdf-schema#label",
    object: `${type} feature ${id}`,
    objectType: "literal"
  });

  // ã‚¸ã‚ªãƒ¡ãƒˆãƒªãƒˆãƒªãƒ—ãƒ«
  triples.push({
    subject: featureUri,
    predicate: "http://www.opengis.net/ont/geosparql#hasGeometry",
    object: geometryUri,
    objectType: "uri"
  });

  triples.push({
    subject: geometryUri,
    predicate: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    object: "http://www.opengis.net/ont/geosparql#Geometry",
    objectType: "uri"
  });

  // GeoJSONå½¢å¼ã§ä¿å­˜
  triples.push({
    subject: geometryUri,
    predicate: "http://www.opengis.net/ont/geosparql#asGeoJSON",
    object: JSON.stringify(geometry),
    objectType: "literal"
  });

  // WKTå½¢å¼ã§ã‚‚ä¿å­˜ï¼ˆwellknownãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ï¼‰
  try {
    const wktString = wellknown.stringify(geometry);
    if (wktString) {
      triples.push({
        subject: geometryUri,
        predicate: "http://www.opengis.net/ont/geosparql#asWKT",
        object: wktString,
        objectType: "literal",
        datatype: "http://www.opengis.net/ont/geosparql#wktLiteral"
      });
    } else {
      console.warn("âš ï¸ wellknown.stringify returned null or empty string");
    }
  } catch (error) {
    console.error(`âŒ Failed to convert geometry to WKT for feature ${id}:`, error);
    console.error("Geometry that failed:", JSON.stringify(geometry, null, 2));
  }

  // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¿½åŠ 
  if (properties) {
    Object.entries(properties).forEach(([key, value]) => {
      if (key === "id") return; // IDã¯æ—¢ã«ä½¿ç”¨æ¸ˆã¿

      const propertyUri = typeConfig.properties[key as keyof typeof typeConfig.properties] || `ex:${key}`;
      const propertyUriString = String(propertyUri);
      const fullPropertyUri = propertyUriString.startsWith("ex:") 
        ? `http://example.org/disaster#${propertyUriString.replace("ex:", "")}` 
        : propertyUriString;

      if (typeof value === "string") {
        triples.push({
          subject: featureUri,
          predicate: fullPropertyUri,
          object: value,
          objectType: "literal"
        });
      } else if (typeof value === "number") {
        triples.push({
          subject: featureUri,
          predicate: fullPropertyUri,
          object: value.toString(),
          objectType: "literal",
          datatype: "http://www.w3.org/2001/XMLSchema#decimal"
        });
      } else if (typeof value === "boolean") {
        triples.push({
          subject: featureUri,
          predicate: fullPropertyUri,
          object: value.toString(),
          objectType: "literal",
          datatype: "http://www.w3.org/2001/XMLSchema#boolean"
        });
      } else if (Array.isArray(value)) {
        triples.push({
          subject: featureUri,
          predicate: fullPropertyUri,
          object: JSON.stringify(value),
          objectType: "literal"
        });
      } else if (value !== null && value !== undefined) {
        console.warn(`Unsupported property type for ${key}: ${typeof value}`);
      }
    });
  }

  return triples;
}

// RDF4J SPARQL ã‚¯ã‚¨ãƒªå®Ÿè¡Œç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
export async function executeRDF4JSPARQLQuery(store: RDF4JStore, query: string): Promise<any> {
  const queryUrl = `${store.baseUrl}/repositories/${store.repositoryId}`;
  
  const response = await fetch(queryUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/sparql-results+json'
    },
    body: query
  });

  if (!response.ok) {
    throw new Error(`SPARQL query failed: ${response.status} ${response.statusText}`);
  }

  return await response.json();
}

// RDF4J bulk insertç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
export async function bulkInsertTriples(store: RDF4JStore, triples: RDFTriple[], batchSize: number = 1000): Promise<void> {
  const insertUrl = `${store.baseUrl}/repositories/${store.repositoryId}/statements`;
  
  // ãƒˆãƒªãƒ—ãƒ«ã‚’Turtleå½¢å¼ã«å¤‰æ›
  const convertToTurtle = (triples: RDFTriple[]): string => {
    const prefixes = `
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix geo: <http://www.opengis.net/ont/geosparql#> .
@prefix ex: <http://example.org/disaster#> .

`;
    
    const tripleStrings = triples.map(triple => {
      const subject = `<${triple.subject}>`;
      const predicate = `<${triple.predicate}>`;
      let object: string;
      
      if (triple.objectType === 'uri') {
        object = `<${triple.object}>`;
      } else {
        if (triple.datatype) {
          object = `"${triple.object.replace(/"/g, '\\"')}"^^<${triple.datatype}>`;
        } else {
          object = `"${triple.object.replace(/"/g, '\\"')}"`;
        }
      }
      
      return `${subject} ${predicate} ${object} .`;
    });
    
    return prefixes + tripleStrings.join('\n');
  };

  // ãƒãƒƒãƒå‡¦ç†ã§ãƒˆãƒªãƒ—ãƒ«ã‚’æŒ¿å…¥
  for (let i = 0; i < triples.length; i += batchSize) {
    const batch = triples.slice(i, i + batchSize);
    const turtleData = convertToTurtle(batch);
    
    const response = await fetch(insertUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'text/turtle'
      },
      body: turtleData
    });

    if (!response.ok) {
      throw new Error(`Failed to insert batch ${Math.floor(i / batchSize) + 1}: ${response.status} ${response.statusText}`);
    }

    console.log(`âœ… Inserted batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(triples.length / batchSize)} (${batch.length} triples)`);
  }
}

// æ—§Oxigraphã‚¯ã‚¨ãƒªå®Ÿè¡Œé–¢æ•°ï¼ˆå»ƒæ­¢äºˆå®šï¼‰
export function executeGeoSPARQLQuery(): any {
  throw new Error("executeGeoSPARQLQuery is deprecated. Use executeRDF4JSPARQLQuery instead.");
}

// ç‰¹å®šã®åœ°åŸŸå†…ã®äººå£ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆRDF4Jç‰ˆï¼‰
export async function getPopulationInArea(
  store: RDF4JStore,
  [[minLng, minLat], [maxLng, maxLat]]: [[number, number], [number, number]],
): Promise<FeatureCollection> {
  const boundingBoxWKT = `POLYGON((${minLng} ${minLat}, ${maxLng} ${minLat}, ${maxLng} ${maxLat}, ${minLng} ${maxLat}, ${minLng} ${minLat}))`;

  const query = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?feature ?geometry ?population ?meshId ?color
    WHERE {
      ?feature rdf:type ex:PopulationFeature ;
        geo:hasGeometry ?geom ;
        ex:population ?population .
      OPTIONAL { ?feature ex:meshId ?meshId }
      OPTIONAL { ?feature ex:color ?color }
      ?geom geo:asGeoJSON ?geometry .
      FILTER(
        geof:sfIntersects(
          "${boundingBoxWKT}"^^geo:wktLiteral,
          ?geometry
        )
      )
    }
    ORDER BY DESC(?population)
  `;

  try {
    const results = await executeRDF4JSPARQLQuery(store, query);

    return {
      type: "FeatureCollection",
      features: results.results?.bindings?.map((result: any) => ({
        type: "Feature",
        geometry: JSON.parse(result.geometry.value),
        properties: {
          population: parseFloat(result.population.value),
          meshId: result.meshId?.value || null,
          color: result.color?.value || null,
        },
      })) || [],
    };
  } catch (error) {
    console.error("Error executing population query:", error);
    return { type: "FeatureCollection", features: [] };
  }
}

// WKTå½¢å¼ã‚’ä½¿ç”¨ã—ãŸç©ºé–“ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã®ä¾‹ï¼ˆå»ƒæ­¢äºˆå®šï¼‰
export async function getPopulationInAreaWithWKT(): Promise<FeatureCollection> {
  throw new Error("getPopulationInAreaWithWKT is deprecated. Use getPopulationInArea instead.");
}

/*
// å»ƒæ­¢äºˆå®šã®é–¢æ•°ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
export async function getPopulationInAreaWithWKT_OLD(
  store: oxigraph.Store,
  [[minLng, minLat], [maxLng, maxLat]]: [[number, number], [number, number]],
): Promise<FeatureCollection> {
*/

// ä»¥ä¸‹ã¯å»ƒæ­¢äºˆå®šã®é–¢æ•°ç¾¤ï¼ˆRDF4Jç‰ˆã¸ã®ç§»è¡Œä¸­ï¼‰

// ç½å®³ã‚¨ãƒªã‚¢ã¨é‡è¤‡ã™ã‚‹é‡è¦æ–½è¨­ã‚’å–å¾—ï¼ˆå»ƒæ­¢äºˆå®šï¼‰
export async function getFacilitiesInDisasterArea(): Promise<{
  schools: FeatureCollection<Point>;
  medical: FeatureCollection<Point>;
}> {
  throw new Error("getFacilitiesInDisasterArea is deprecated. Use RDF4J version instead.");
}

/*
export async function getFacilitiesInDisasterArea_OLD(
  store: oxigraph.Store,
  disasterArea: Feature<Polygon>,
): Promise<{
  schools: FeatureCollection<Point>;
  medical: FeatureCollection<Point>;
}> {
  const escapedGeometry = JSON.stringify(disasterArea.geometry).replace(/"/gu, '\\"');

  const query = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?feature ?geometry ?type ?name ?capacity ?emergencyRole
    WHERE {
      {
        ?feature rdf:type ex:SchoolFeature ;
          geo:hasGeometry ?geom .
        OPTIONAL { ?feature ex:facilityName ?name }
        OPTIONAL { ?feature ex:capacity ?capacity }
        OPTIONAL { ?feature ex:emergencyRole ?emergencyRole }
        BIND("school" as ?type)
      } UNION {
        ?feature rdf:type ex:MedicalFeature ;
          geo:hasGeometry ?geom .
        OPTIONAL { ?feature ex:facilityName ?name }
        OPTIONAL { ?feature ex:capacity ?capacity }
        OPTIONAL { ?feature ex:emergencyCapacity ?emergencyRole }
        BIND("medical" as ?type)
      }
      ?geom geo:asGeoJSON ?geometry .
      FILTER(
        geof:sfIntersects(
          ?geometry,
          "${escapedGeometry}"^^geo:geoJSONLiteral
        )
      )
    }
    ORDER BY ?type ?name
  `;

  try {
    const results = await executeGeoSPARQLQuery(store, query);

    const schools: Feature<Point>[] = [];
    const medical: Feature<Point>[] = [];

    results.forEach((result: any) => {
      const feature: Feature<Point> = {
        type: "Feature",
        geometry: JSON.parse(result.geometry.value),
        properties: {
          name: result.name?.value || "Unknown",
          capacity: result.capacity ? parseInt(result.capacity.value, 10) : null,
          emergencyRole: result.emergencyRole?.value || null,
        },
      };

      if (result.type.value === "school") {
        schools.push(feature);
      } else {
        medical.push(feature);
      }
    });

    return {
      schools: { type: "FeatureCollection", features: schools },
      medical: { type: "FeatureCollection", features: medical },
    };
  } catch (error) {
    console.error("Error executing facilities query:", error);
    return {
      schools: { type: "FeatureCollection", features: [] },
      medical: { type: "FeatureCollection", features: [] },
    };
  }
}

// åœŸåœ°åˆ©ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
export async function getLandUseInArea(
  store: oxigraph.Store,
  [[minLng, minLat], [maxLng, maxLat]]: [[number, number], [number, number]],
): Promise<FeatureCollection> {
  const boundingBoxWKT = `POLYGON((${minLng} ${minLat}, ${maxLng} ${minLat}, ${maxLng} ${maxLat}, ${minLng} ${maxLat}, ${minLng} ${minLat}))`;

  const query = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?feature ?geometry ?landUseType ?area ?classification
    WHERE {
      ?feature rdf:type ex:LandUseFeature ;
        geo:hasGeometry ?geom ;
        ex:landUseCode ?landUseCode .
      OPTIONAL { ?feature ex:color }
      ?geom geo:asGeoJSON ?geometry .
      FILTER(
        geof:sfIntersects(
          ?geometry,
          "${boundingBoxWKT}"^^geo:wktLiteral
        )
      )
    }
    ORDER BY ?landUseType
  `;

  try {
    const results = await executeGeoSPARQLQuery(store, query);

    return {
      type: "FeatureCollection",
      features: results.map((result: any) => ({
        type: "Feature",
        geometry: JSON.parse(result.geometry.value),
        properties: {
          type: result.landUseType.value,
          area: result.area ? parseFloat(result.area.value) : null,
          classification: result.classification?.value || null,
        },
      })),
    };
  } catch (error) {
    console.error("Error executing land use query:", error);
    return { type: "FeatureCollection", features: [] };
  }
}

// ãƒ‡ãƒ¼ã‚¿ã‚’RDF4Jã‚¹ãƒˆã‚¢ã«ä¿å­˜ï¼ˆTriple ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç‰ˆï¼‰
export async function saveDataToRDF4J(
  store: RDF4JStore,
  data: {
    populationData: FeatureCollection;
    landUseData: FeatureCollection;
    schoolData: FeatureCollection;
    medicalData: FeatureCollection;
    disasterData: FeatureCollection;
  },
  batchSize: number = 1000
): Promise<number> {
  console.log("ğŸ”„ Starting RDF4J store save operation...");
  console.log("ğŸ“Š Data counts:", {
    population: data.populationData.features.length,
    landUse: data.landUseData.features.length,
    school: data.schoolData.features.length,
    medical: data.medicalData.features.length,
    disaster: data.disasterData.features.length,
  });

  try {
    let allTriples: RDFTriple[] = [];
    let totalConvertedFeatures = 0;
    let totalErrors = 0;

    // ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ã‚’å‡¦ç†ã—ã¦ãƒˆãƒªãƒ—ãƒ«ã«å¤‰æ›
    const processFeatures = (features: Feature[], type: keyof typeof DATA_PROPERTIES): RDFTriple[] => {
      console.log(`ğŸ”¨ Processing ${features.length} ${type} features...`);
      let convertedCount = 0;
      let errorCount = 0;
      const featureTriples: RDFTriple[] = [];

      features.forEach((feature, index) => {
        try {
          const triples = convertGeoJSONToTriples(feature, type);
          featureTriples.push(...triples);
          convertedCount++;

          if (index % 100 === 0 && index > 0) {
            console.log(`ğŸ“Š Progress: ${index}/${features.length} ${type} features processed`);
          }
        } catch (error) {
          errorCount++;
          console.error(`âŒ Error converting ${type} feature ${index}:`, error);
        }
      });

      console.log(`ğŸ“ˆ ${type}: ${convertedCount} converted, ${errorCount} errors, ${featureTriples.length} triples`);
      totalConvertedFeatures += convertedCount;
      totalErrors += errorCount;
      
      return featureTriples;
    };

    // å„ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã‚’å‡¦ç†
    if (data.populationData.features.length > 0) {
      const populationTriples = processFeatures(data.populationData.features, "population");
      allTriples.push(...populationTriples);
    }

    if (data.landUseData.features.length > 0) {
      const landUseTriples = processFeatures(data.landUseData.features, "landuse");
      allTriples.push(...landUseTriples);
    }

    if (data.schoolData.features.length > 0) {
      const schoolTriples = processFeatures(data.schoolData.features, "school");
      allTriples.push(...schoolTriples);
    }

    if (data.medicalData.features.length > 0) {
      const medicalTriples = processFeatures(data.medicalData.features, "medical");
      allTriples.push(...medicalTriples);
    }

    if (data.disasterData.features.length > 0) {
      const disasterTriples = processFeatures(data.disasterData.features, "disaster");
      allTriples.push(...disasterTriples);
    }

    console.log(`âœ… Successfully converted ${totalConvertedFeatures} features to ${allTriples.length} triples with ${totalErrors} errors`);

    // RDF4Jã«ãƒãƒ«ã‚¯ã‚¤ãƒ³ã‚µãƒ¼ãƒˆ
    if (allTriples.length > 0) {
      console.log("ğŸš€ Starting bulk insert to RDF4J...");
      await bulkInsertTriples(store, allTriples, batchSize);
      console.log("âœ… Bulk insert completed successfully");
    }

    return allTriples.length;
  } catch (error) {
    console.error("âŒ Error saving data to RDF4J store:", error);
    throw error;
  }
}

// ã‚¹ãƒˆã‚¢ã®æ¤œè¨¼æ©Ÿèƒ½
export function validateStore(store: oxigraph.Store): void {
  console.log("ğŸ” Validating GeoSPARQL store...");

  try {
    // åŸºæœ¬çš„ãªã‚«ã‚¦ãƒ³ãƒˆã‚¯ã‚¨ãƒª
    const countQuery = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      PREFIX ex: <http://example.org/disaster#>
      
      SELECT (COUNT(*) as ?count)
      WHERE {
        ?s ?p ?o .
      }
    `;

    const countResult = store.query(countQuery);
    console.log("ğŸ“Š Total triples in store:", countResult);

    // å„ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã®ã‚«ã‚¦ãƒ³ãƒˆ
    const typeCountQuery = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      PREFIX ex: <http://example.org/disaster#>
      
      SELECT ?type (COUNT(*) as ?count)
      WHERE {
        ?s rdf:type ?type .
      }
      GROUP BY ?type
    `;

    const typeResults = store.query(typeCountQuery);
    console.log("ğŸ“ˆ Features by type:", typeResults);

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ç¢ºèª
    const sampleQuery = `
      PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
      PREFIX ex: <http://example.org/disaster#>
      
      SELECT ?s ?p ?o
      WHERE {
        ?s ?p ?o .
      }
      LIMIT 5
    `;

    const sampleResults = store.query(sampleQuery);
    console.log("ğŸ” Sample triples:", sampleResults);
  } catch (error) {
    console.error("âŒ Error validating store:", error);
  }
}

// ç½å®³ã‚¨ãƒªã‚¢ã®ç·åˆåˆ†æï¼ˆæœ€é©åŒ–ç‰ˆï¼‰
export async function analyzeDisasterArea(
  store: oxigraph.Store,
  disasterArea: Feature<Polygon>,
): Promise<{
  population: number;
  schools: number;
  medical: number;
  landUse: { [key: string]: number };
  emergencyCapacity: {
    schoolCapacity: number;
    medicalCapacity: number;
    emergencyMedicalCapacity: number;
  };
}> {
  const escapedGeometry = wellknown.stringify(disasterArea.geometry);

  // çµ±åˆã‚¯ã‚¨ãƒªã§å…¨æƒ…å ±ã‚’ä¸€åº¦ã«å–å¾—ï¼ˆã‚µãƒ–ã‚¯ã‚¨ãƒªã‚’ä½¿ç”¨ã—ã¦æ­£ã—ãé›†è¨ˆï¼‰
  const comprehensiveQuery = `
    ${GEOSPARQL_PREFIXES}
    SELECT 
      ?totalPopulation ?schoolCount ?medicalCount ?totalSchoolCapacity ?totalMedicalCapacity ?totalEmergencyCapacity
    WHERE {
      {
        SELECT (SUM(?population) as ?totalPopulation)
        WHERE {
          ?popFeature rdf:type ex:PopulationFeature ;
            geo:hasGeometry ?popGeom ;
            ex:population ?population .
          ?popGeom geo:asWKT ?popGeometry .
          FILTER(
            geof:sfIntersects(
              ?popGeometry,
              "${escapedGeometry}"^^geo:wktLiteral
            )
          )
        }
      }
      {
        SELECT (COUNT(DISTINCT ?school) as ?schoolCount) (SUM(?schoolCapacity) as ?totalSchoolCapacity)
        WHERE {
          ?school rdf:type ex:SchoolFeature ;
            geo:hasGeometry ?schoolGeom .
          OPTIONAL { ?school ex:capacity ?schoolCapacity }
          ?schoolGeom geo:asWKT ?schoolGeometry .
          FILTER(
            geof:sfIntersects(
              ?schoolGeometry,
              "${escapedGeometry}"^^geo:wktLiteral
            )
          )
        }
      }
      {
        SELECT (COUNT(DISTINCT ?medical) as ?medicalCount) (SUM(?medicalCapacity) as ?totalMedicalCapacity) (SUM(?emergencyCapacity) as ?totalEmergencyCapacity)
        WHERE {
          ?medical rdf:type ex:MedicalFeature ;
            geo:hasGeometry ?medicalGeom .
          OPTIONAL { ?medical ex:capacity ?medicalCapacity }
          OPTIONAL { ?medical ex:emergencyCapacity ?emergencyCapacity }
          ?medicalGeom geo:asWKT ?medicalGeometry .
          FILTER(
            geof:sfIntersects(
              ?medicalGeometry,
              "${escapedGeometry}"^^geo:wktLiteral
            )
          )
        }
      }
    }
  `;

  // åœŸåœ°åˆ©ç”¨ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
  const landUseQuery = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?landUseCode (COUNT(DISTINCT ?feature) as ?count) 
    WHERE {
      ?feature rdf:type ex:LandUseFeature ;
        geo:hasGeometry ?geom ;
        ex:landUseCode ?landUseCode .
      ?geom geo:asWKT ?geometry .
      FILTER(
        geof:sfIntersects(
          ?geometry,
          "${escapedGeometry}"^^geo:wktLiteral
        )
      )
    }
    GROUP BY ?landUseCode
    ORDER BY DESC(?count)
  `;

  try {
    const [comprehensiveResult, landUseResult] = await Promise.all([
      executeGeoSPARQLQuery(store, comprehensiveQuery),
      executeGeoSPARQLQuery(store, landUseQuery),
    ]);

    const result = comprehensiveResult[0] as Map<string, any>;
    console.log(comprehensiveResult[0], result, result.get("totalPopulation").value);
    const totalPopulation = result.get("totalPopulation").value || 0;
    const schools = result.get("schoolCount").value || 0;
    const medical = result.get("medicalCount").value || 0;
    const schoolCapacity = result.get("totalSchoolCapacity")?.value || 0;
    const medicalCapacity = result.get("totalMedicalCapacity")?.value || 0;
    const emergencyCapacity = result.get("totalEmergencyCapacity")?.value || 0;

    const landUse = landUseResult.reduce((acc: { [key: string]: number }, curr: any) => {
      acc[curr.landUseType.value] = parseInt(curr.count.value, 10);
      return acc;
    }, {});

    return {
      population: parseFloat(totalPopulation),
      schools: parseInt(schools, 10),
      medical: parseInt(medical, 10),
      landUse,
      emergencyCapacity: {
        schoolCapacity: parseInt(schoolCapacity, 10),
        medicalCapacity: parseInt(medicalCapacity, 10),
        emergencyMedicalCapacity: parseInt(emergencyCapacity, 10),
      },
    };
  } catch (error) {
    console.error("Error analyzing disaster area:", error);
    return {
      population: 0,
      schools: 0,
      medical: 0,
      landUse: {},
      emergencyCapacity: {
        schoolCapacity: 0,
        medicalCapacity: 0,
        emergencyMedicalCapacity: 0,
      },
    };
  }
}

// ç½å®³å¯¾å¿œèƒ½åŠ›ã®è©•ä¾¡
export async function evaluateDisasterResponse(
  store: oxigraph.Store,
  disasterArea: Feature<Polygon>,
): Promise<{
  riskLevel: "low" | "medium" | "high" | "critical";
  analysis: string;
  recommendations: string[];
}> {
  const analysis = await analyzeDisasterArea(store, disasterArea);
  console.log(analysis);
  const populationDensity = analysis.population;
  const medicalRatio = analysis.population > 0 ? (analysis.medical * 10) / analysis.population : 0;
  const schoolCapacityRatio = analysis.population > 0 ? (analysis.schools * 100) / analysis.population : 0;

  let riskLevel: "low" | "medium" | "high" | "critical" = "low";
  const recommendations: string[] = [];

  if (populationDensity > 10000) {
    riskLevel = "high";
    recommendations.push("é«˜äººå£å¯†åº¦ã‚¨ãƒªã‚¢ - è¿½åŠ ã®é¿é›£è¨ˆç”»ãŒå¿…è¦");
  }

  if (medicalRatio < 0.01) {
    riskLevel = riskLevel === "low" ? "medium" : "critical";
    recommendations.push("åŒ»ç™‚æ–½è¨­ã®ç·Šæ€¥å¯¾å¿œèƒ½åŠ›ãŒä¸è¶³ - è¿‘éš£ã‹ã‚‰ã®æ”¯æ´ä½“åˆ¶ã‚’ç¢ºä¿");
  }

  if (schoolCapacityRatio < 0.1) {
    recommendations.push("é¿é›£æ‰€ã¨ã—ã¦ã®å­¦æ ¡åå®¹èƒ½åŠ›ãŒä¸è¶³ - ä»£æ›¿é¿é›£æ‰€ã®ç¢ºä¿ã‚’æ¤œè¨");
  }

  if (analysis.medical === 0) {
    riskLevel = "critical";
    recommendations.push("åŒ»ç™‚æ–½è¨­ãŒå­˜åœ¨ã—ãªã„ - ç·Šæ€¥åŒ»ç™‚ãƒãƒ¼ãƒ ã®æ´¾é£ãŒå¿…è¦");
  }

  const analysisText = `äººå£: ${analysis.population}äºº, å­¦æ ¡: ${analysis.schools}æ–½è¨­, åŒ»ç™‚: ${analysis.medical}æ–½è¨­`;

  return {
    riskLevel,
    analysis: analysisText,
    recommendations,
  };
}

// WKTå½¢å¼ã§ã®ä¿å­˜æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã®é–¢æ•°
export function testWKTStorage(store: oxigraph.Store): void {
  console.log("ğŸ§ª Testing WKT storage functionality...");

  const testQuery = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?feature ?geometry ?wkt
    WHERE {
      ?feature rdf:type ex:PopulationFeature ;
        geo:hasGeometry ?geom .
      OPTIONAL { ?geom geo:asGeoJSON ?geometry }
      OPTIONAL { ?geom geo:asWKT ?wkt }
    }
    LIMIT 5
  `;

  try {
    const results = executeGeoSPARQLQuery(store, testQuery);
    console.log("ğŸ“Š WKT Storage Test Results:");
    results.forEach((result: any, index: number) => {
      console.log(`Result ${index + 1}:`);
      console.log(`  Feature: ${result.feature?.value}`);
      console.log(`  GeoJSON: ${result.geometry?.value ? "Available" : "Not available"}`);
      console.log(`  WKT: ${result.wkt?.value ? "Available" : "Not available"}`);
      if (result.wkt?.value) {
        console.log(`  WKT Content: ${result.wkt.value}`);
      }
    });
  } catch (error) {
    console.error("âŒ WKT storage test failed:", error);
  }
}

// WKTå½¢å¼ã§ã®ä¿å­˜æ©Ÿèƒ½ã‚’ãƒ‡ãƒãƒƒã‚°ã™ã‚‹ãŸã‚ã®é–¢æ•°
export function debugWKTStorage(store: oxigraph.Store): void {
  console.log("ğŸ” Debugging WKT storage...");

  // 1. åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿å­˜åœ¨ç¢ºèª
  const basicQuery = `
    ${GEOSPARQL_PREFIXES}
    SELECT ?feature ?geom
    WHERE {
      ?feature rdf:type ex:PopulationFeature ;
        geo:hasGeometry ?geom .
    }
    LIMIT 3
  `;

  try {
    const basicResults = executeGeoSPARQLQuery(store, basicQuery);
    console.log("ğŸ“Š Basic geometry results:", basicResults);

    if (basicResults.length === 0) {
      console.log("âŒ No population features found");
      return;
    }

    // 2. å„å¹¾ä½•å­¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è©³ç´°ç¢ºèª
    basicResults.forEach((result: any, index: number) => {
      const featureUri = result.feature?.value;
      const geomUri = result.geom?.value;

      console.log(`\nğŸ” Geometry ${index + 1}:`);
      console.log(`  Feature: ${featureUri}`);
      console.log(`  Geometry: ${geomUri}`);

      // 3. ç‰¹å®šã®å¹¾ä½•å­¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å…¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç¢ºèª
      const detailQuery = `
        ${GEOSPARQL_PREFIXES}
        SELECT ?property ?value
        WHERE {
          <${geomUri}> ?property ?value .
        }
      `;

      try {
        const detailResults = executeGeoSPARQLQuery(store, detailQuery);
        console.log(`  Properties of geometry ${index + 1}:`);
        detailResults.forEach((prop: any) => {
          console.log(`    ${prop.property?.value}: ${prop.value?.value}`);
        });
      } catch (error) {
        console.error(`  Error getting properties for geometry ${index + 1}:`, error);
      }
    });
  } catch (error) {
    console.error("âŒ Basic query failed:", error);
  }
}
